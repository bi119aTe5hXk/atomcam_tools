diff --git a/internal/api/static.go b/internal/api/static.go
index 9d9335e..cf56b0e 100644
--- a/internal/api/static.go
+++ b/internal/api/static.go
@@ -1,7 +1,7 @@
 package api
 
 import (
-	"github.com/AlexxIT/go2rtc/www"
+	"github.com/AlexxIT/go2rtc/www2"
 	"net/http"
 )
 
diff --git a/internal/homekit/homekit.go b/internal/homekit/homekit.go
index bfe3e97..53c4f5a 100644
--- a/internal/homekit/homekit.go
+++ b/internal/homekit/homekit.go
@@ -25,7 +25,9 @@ func Init() {
 			Pin           string   `yaml:"pin"`
 			Name          string   `yaml:"name"`
 			DeviceID      string   `yaml:"device_id"`
+			SetupID       string   `yaml:"setup_id"`
 			DevicePrivate string   `yaml:"device_private"`
+			Image         string   `yaml:"image_stream"`
 			Pairings      []string `yaml:"pairings"`
 		} `yaml:"homekit"`
 	}
@@ -36,6 +38,7 @@ func Init() {
 	streams.HandleFunc("homekit", streamHandler)
 
 	api.HandleFunc("api/homekit", apiHandler)
+	api.HandleFunc("api/homekit/setupURI", apiSetupHandler)
 
 	if cfg.Mod == nil {
 		return
@@ -62,10 +65,13 @@ func Init() {
 		}
 
 		deviceID := calcDeviceID(conf.DeviceID, id) // random MAC-address
+		setupID := (conf.SetupID + "HMXS")[:4] // default setup ID
 		name := calcName(conf.Name, deviceID)
 
 		srv := &server{
 			stream:   id,
+			image:    conf.Image,
+			name:     conf.Name,
 			srtp:     srtp.Server,
 			pairings: conf.Pairings,
 		}
@@ -73,6 +79,7 @@ func Init() {
 		srv.hap = &hap.Server{
 			Pin:           pin,
 			DeviceID:      deviceID,
+			SetupID:       setupID,
 			DevicePrivate: calcDevicePrivate(conf.DevicePrivate, id),
 			GetPair:       srv.GetPair,
 			AddPair:       srv.AddPair,
@@ -113,6 +120,7 @@ func Init() {
 		entries = append(entries, srv.mdns)
 
 		srv.UpdateStatus()
+		srv.setupURI = srv.hap.SetupURI()
 
 		host := srv.mdns.Host(mdns.ServiceHAP)
 		servers[host] = srv
@@ -199,3 +207,26 @@ func findHomeKitURL(stream *streams.Stream) string {
 
 	return ""
 }
+
+type SetupInfo struct {
+  Name         string
+  DeviceID     string
+  SetupURI     string
+}
+
+func apiSetupHandler(w http.ResponseWriter, r *http.Request) {
+	if r.Method != "GET" {
+		http.Error(w, "", http.StatusBadRequest)
+		return
+	}
+
+	res := make([]*SetupInfo, 0, len(servers))
+	for _, s := range servers {
+		res = append(res, &SetupInfo{
+			Name: s.name,
+			DeviceID: s.hap.DeviceID,
+			SetupURI: s.setupURI,
+		})
+	}
+	api.ResponseJSON(w, res)
+}
diff --git a/internal/homekit/server.go b/internal/homekit/server.go
index cb114fe..27a4a36 100644
--- a/internal/homekit/server.go
+++ b/internal/homekit/server.go
@@ -25,11 +25,14 @@ import (
 
 type server struct {
 	stream    string      // stream name from YAML
+	image     string
+	name      string
 	hap       *hap.Server // server for HAP connection and encryption
 	mdns      *mdns.ServiceEntry
 	srtp      *srtp.Server
 	accessory *hap.Accessory // HAP accessory
 	pairings  []string       // pairings list
+	setupURI  string
 
 	streams  map[string]*homekit.Consumer
 	consumer *homekit.Consumer
@@ -142,7 +145,11 @@ func (s *server) SetCharacteristic(conn net.Conn, aid uint8, iid uint64, value a
 func (s *server) GetImage(conn net.Conn, width, height int) []byte {
 	log.Trace().Msgf("[homekit] %s: get image width=%d height=%d", conn.RemoteAddr(), width, height)
 
-	stream := streams.Get(s.stream)
+	streamId := s.stream
+	if(s.image != "") {
+		streamId = s.image
+	}
+	stream := streams.Get(streamId)
 	cons := magic.NewKeyframe()
 
 	if err := stream.AddConsumer(cons); err != nil {
diff --git a/main.go b/main.go
index 91bc993..4ae836f 100644
--- a/main.go
+++ b/main.go
@@ -4,90 +4,25 @@ import (
 	"github.com/AlexxIT/go2rtc/internal/api"
 	"github.com/AlexxIT/go2rtc/internal/api/ws"
 	"github.com/AlexxIT/go2rtc/internal/app"
-	"github.com/AlexxIT/go2rtc/internal/bubble"
-	"github.com/AlexxIT/go2rtc/internal/debug"
-	"github.com/AlexxIT/go2rtc/internal/dvrip"
-	"github.com/AlexxIT/go2rtc/internal/echo"
-	"github.com/AlexxIT/go2rtc/internal/exec"
-	"github.com/AlexxIT/go2rtc/internal/expr"
-	"github.com/AlexxIT/go2rtc/internal/ffmpeg"
-	"github.com/AlexxIT/go2rtc/internal/gopro"
-	"github.com/AlexxIT/go2rtc/internal/hass"
-	"github.com/AlexxIT/go2rtc/internal/hls"
 	"github.com/AlexxIT/go2rtc/internal/homekit"
 	"github.com/AlexxIT/go2rtc/internal/http"
-	"github.com/AlexxIT/go2rtc/internal/isapi"
-	"github.com/AlexxIT/go2rtc/internal/ivideon"
-	"github.com/AlexxIT/go2rtc/internal/mjpeg"
-	"github.com/AlexxIT/go2rtc/internal/mp4"
-	"github.com/AlexxIT/go2rtc/internal/mpegts"
-	"github.com/AlexxIT/go2rtc/internal/nest"
-	"github.com/AlexxIT/go2rtc/internal/ngrok"
-	"github.com/AlexxIT/go2rtc/internal/onvif"
-	"github.com/AlexxIT/go2rtc/internal/roborock"
-	"github.com/AlexxIT/go2rtc/internal/rtmp"
 	"github.com/AlexxIT/go2rtc/internal/rtsp"
 	"github.com/AlexxIT/go2rtc/internal/srtp"
 	"github.com/AlexxIT/go2rtc/internal/streams"
-	"github.com/AlexxIT/go2rtc/internal/tapo"
 	"github.com/AlexxIT/go2rtc/internal/webrtc"
-	"github.com/AlexxIT/go2rtc/internal/webtorrent"
 	"github.com/AlexxIT/go2rtc/pkg/shell"
 )
 
 func main() {
 	// 1. Core modules: app, api/ws, streams
-
 	app.Init() // init config and logs
-
 	api.Init() // init API before all others
 	ws.Init()  // init WS API endpoint
-
 	streams.Init() // streams module
-
-	// 2. Main sources and servers
-
 	rtsp.Init()   // rtsp source, RTSP server
 	webrtc.Init() // webrtc source, WebRTC server
-
-	// 3. Main API
-
-	mp4.Init()   // MP4 API
-	hls.Init()   // HLS API
-	mjpeg.Init() // MJPEG API
-
-	// 4. Other sources and servers
-
-	hass.Init()       // hass source, Hass API server
-	onvif.Init()      // onvif source, ONVIF API server
-	webtorrent.Init() // webtorrent source, WebTorrent module
-
-	// 5. Other sources
-
-	rtmp.Init()     // rtmp source
-	exec.Init()     // exec source
-	ffmpeg.Init()   // ffmpeg source
-	echo.Init()     // echo source
-	ivideon.Init()  // ivideon source
 	http.Init()     // http/tcp source
-	dvrip.Init()    // dvrip source
-	tapo.Init()     // tapo source
-	isapi.Init()    // isapi source
-	mpegts.Init()   // mpegts passive source
-	roborock.Init() // roborock source
 	homekit.Init()  // homekit source
-	nest.Init()     // nest source
-	bubble.Init()   // bubble source
-	expr.Init()     // expr source
-	gopro.Init()    // gopro source
-
-	// 6. Helper modules
-
-	ngrok.Init() // ngrok module
 	srtp.Init()  // SRTP server
-	debug.Init() // debug API
-
-	// 7. Go
-
 	shell.RunUntilSignal()
 }
diff --git a/pkg/hap/helpers.go b/pkg/hap/helpers.go
index ea5e405..9d0f206 100644
--- a/pkg/hap/helpers.go
+++ b/pkg/hap/helpers.go
@@ -34,6 +34,7 @@ const (
 	CategoryBridge   = "2"
 	CategoryCamera   = "17"
 	CategoryDoorbell = "18"
+	CategoryIPCamera = "19"
 
 	StateM1 = 1
 	StateM2 = 2
diff --git a/pkg/hap/server.go b/pkg/hap/server.go
index 2a91232..1fbe6fb 100644
--- a/pkg/hap/server.go
+++ b/pkg/hap/server.go
@@ -9,6 +9,8 @@ import (
 	"io"
 	"net"
 	"net/http"
+	"strings"
+	"strconv"
 
 	"github.com/AlexxIT/go2rtc/pkg/hap/chacha20poly1305"
 	"github.com/AlexxIT/go2rtc/pkg/hap/curve25519"
@@ -23,6 +25,7 @@ type HandlerFunc func(net.Conn) error
 type Server struct {
 	Pin           string
 	DeviceID      string
+	SetupID       string
 	DevicePrivate []byte
 
 	GetPair func(conn net.Conn, id string) []byte
@@ -45,10 +48,23 @@ func (s *Server) ServerPublic() []byte {
 func (s *Server) SetupHash() string {
 	// should be setup_id (random 4 alphanum) + device_id (mac address)
 	// but device_id is random, so OK
-	b := sha512.Sum512([]byte(s.DeviceID))
+	b := sha512.Sum512([]byte(s.SetupID[:4] + s.DeviceID))
 	return base64.StdEncoding.EncodeToString(b[:4])
 }
 
+func (s *Server) SetupURI() string {
+	// for QR-Code
+	category, _ := strconv.ParseInt(CategoryIPCamera, 10, 64)
+	pin, _ := strconv.ParseInt(strings.Replace(s.Pin, "-", "", -1), 10, 64)
+	d := (category &^ 1) << 31 + 1 << 28 + pin
+	if category & 1 == 1 {
+		d -= 1 << 31
+	}
+	payload := "00000" + strconv.FormatInt(d, 36)
+	uri := strings.ToUpper("X-HM://" + payload[len(payload)-9:] + s.SetupID[:4])
+	return uri
+}
+
 func (s *Server) PairVerify(req *http.Request, rw *bufio.ReadWriter, conn net.Conn) error {
 	// Request from iPhone
 	var plainM1 struct {
diff --git a/www2/index.html b/www2/index.html
new file mode 100644
index 0000000..dc74f12
--- /dev/null
+++ b/www2/index.html
@@ -0,0 +1,38 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta name="viewport" content="width=device-width, initial-scale=1">
+    <title>go2rtc - Stream</title>
+    <style>
+        body {
+            background: black;
+            margin: 0;
+            padding: 0;
+            display: flex;
+            font-family: Arial, Helvetica, sans-serif;
+        }
+
+        html, body {
+            height: 100%;
+            width: 100%;
+        }
+
+        .flex {
+            flex-wrap: wrap;
+            align-content: flex-start;
+            align-items: flex-start;
+        }
+    </style>
+</head>
+<body>
+<script type="module" src="./video-stream.js"></script>
+<script type="module">
+    const video = document.createElement('video-stream');
+    video.background = true;
+    video.mode = 'webrtc';
+    video.style.flex = '1 0 320px';
+    video.src = new URL('api/ws?src=video0', location.href);
+    document.body.appendChild(video);
+</script>
+</body>
+</html>
diff --git a/www2/static.go b/www2/static.go
new file mode 100644
index 0000000..01f5090
--- /dev/null
+++ b/www2/static.go
@@ -0,0 +1,7 @@
+package www
+
+import "embed"
+
+//go:embed *.html
+//go:embed *.js
+var Static embed.FS
diff --git a/www2/video-rtc.js b/www2/video-rtc.js
new file mode 100644
index 0000000..7832e10
--- /dev/null
+++ b/www2/video-rtc.js
@@ -0,0 +1,663 @@
+/**
+ * VideoRTC v1.6.0 - Video player for go2rtc streaming application.
+ *
+ * All modern web technologies are supported in almost any browser except Apple Safari.
+ *
+ * Support:
+ * - ECMAScript 2017 (ES8) = ES6 + async
+ * - RTCPeerConnection for Safari iOS 11.0+
+ * - IntersectionObserver for Safari iOS 12.2+
+ * - ManagedMediaSource for Safari 17+
+ *
+ * Doesn't support:
+ * - MediaSource for Safari iOS
+ * - Customized built-in elements (extends HTMLVideoElement) because Safari
+ * - Autoplay for WebRTC in Safari
+ */
+export class VideoRTC extends HTMLElement {
+    constructor() {
+        super();
+
+        this.DISCONNECT_TIMEOUT = 5000;
+        this.RECONNECT_TIMEOUT = 30000;
+
+        this.CODECS = [
+            'avc1.640029',      // H.264 high 4.1 (Chromecast 1st and 2nd Gen)
+            'avc1.64002A',      // H.264 high 4.2 (Chromecast 3rd Gen)
+            'avc1.640033',      // H.264 high 5.1 (Chromecast with Google TV)
+            'hvc1.1.6.L153.B0', // H.265 main 5.1 (Chromecast Ultra)
+            'mp4a.40.2',        // AAC LC
+            'mp4a.40.5',        // AAC HE
+            'flac',             // FLAC (PCM compatible)
+            'opus',             // OPUS Chrome, Firefox
+        ];
+
+        /**
+         * [config] Supported modes (webrtc, webrtc/tcp, mse, hls, mp4, mjpeg).
+         * @type {string}
+         */
+        this.mode = 'webrtc,mse,hls,mjpeg';
+
+        /**
+         * [Config] Requested medias (video, audio, microphone).
+         * @type {string}
+         */
+        this.media = 'video,audio';
+
+        /**
+         * [config] Run stream when not displayed on the screen. Default `false`.
+         * @type {boolean}
+         */
+        this.background = false;
+
+        /**
+         * [config] Run stream only when player in the viewport. Stop when user scroll out player.
+         * Value is percentage of visibility from `0` (not visible) to `1` (full visible).
+         * Default `0` - disable;
+         * @type {number}
+         */
+        this.visibilityThreshold = 0;
+
+        /**
+         * [config] Run stream only when browser page on the screen. Stop when user change browser
+         * tab or minimise browser windows.
+         * @type {boolean}
+         */
+        this.visibilityCheck = true;
+
+        /**
+         * [config] WebRTC configuration
+         * @type {RTCConfiguration}
+         */
+        this.pcConfig = {
+            bundlePolicy: 'max-bundle',
+            iceServers: [{urls: 'stun:stun.l.google.com:19302'}],
+            sdpSemantics: 'unified-plan',  // important for Chromecast 1
+        };
+
+        /**
+         * [info] WebSocket connection state. Values: CONNECTING, OPEN, CLOSED
+         * @type {number}
+         */
+        this.wsState = WebSocket.CLOSED;
+
+        /**
+         * [info] WebRTC connection state.
+         * @type {number}
+         */
+        this.pcState = WebSocket.CLOSED;
+
+        /**
+         * @type {HTMLVideoElement}
+         */
+        this.video = null;
+
+        /**
+         * @type {WebSocket}
+         */
+        this.ws = null;
+
+        /**
+         * @type {string|URL}
+         */
+        this.wsURL = '';
+
+        /**
+         * @type {RTCPeerConnection}
+         */
+        this.pc = null;
+
+        /**
+         * @type {number}
+         */
+        this.connectTS = 0;
+
+        /**
+         * @type {string}
+         */
+        this.mseCodecs = '';
+
+        /**
+         * [internal] Disconnect TimeoutID.
+         * @type {number}
+         */
+        this.disconnectTID = 0;
+
+        /**
+         * [internal] Reconnect TimeoutID.
+         * @type {number}
+         */
+        this.reconnectTID = 0;
+
+        /**
+         * [internal] Handler for receiving Binary from WebSocket.
+         * @type {Function}
+         */
+        this.ondata = null;
+
+        /**
+         * [internal] Handlers list for receiving JSON from WebSocket.
+         * @type {Object.<string,Function>}
+         */
+        this.onmessage = null;
+    }
+
+    /**
+     * Set video source (WebSocket URL). Support relative path.
+     * @param {string|URL} value
+     */
+    set src(value) {
+        if (typeof value !== 'string') value = value.toString();
+        if (value.startsWith('http')) {
+            value = 'ws' + value.substring(4);
+        } else if (value.startsWith('/')) {
+            value = 'ws' + location.origin.substring(4) + value;
+        }
+
+        this.wsURL = value;
+
+        this.onconnect();
+    }
+
+    /**
+     * Play video. Support automute when autoplay blocked.
+     * https://developer.chrome.com/blog/autoplay/
+     */
+    play() {
+        this.video.play().catch(() => {
+            if (!this.video.muted) {
+                this.video.muted = true;
+                this.video.play().catch(er => {
+                    console.warn(er);
+                });
+            }
+        });
+    }
+
+    /**
+     * Send message to server via WebSocket
+     * @param {Object} value
+     */
+    send(value) {
+        if (this.ws) this.ws.send(JSON.stringify(value));
+    }
+
+    /** @param {Function} isSupported */
+    codecs(isSupported) {
+        return this.CODECS
+            .filter(codec => this.media.indexOf(codec.indexOf('vc1') > 0 ? 'video' : 'audio') >= 0)
+            .filter(codec => isSupported(`video/mp4; codecs="${codec}"`)).join();
+    }
+
+    /**
+     * `CustomElement`. Invoked each time the custom element is appended into a
+     * document-connected element.
+     */
+    connectedCallback() {
+        if (this.disconnectTID) {
+            clearTimeout(this.disconnectTID);
+            this.disconnectTID = 0;
+        }
+
+        // because video autopause on disconnected from DOM
+        if (this.video) {
+            const seek = this.video.seekable;
+            if (seek.length > 0) {
+                this.video.currentTime = seek.end(seek.length - 1);
+            }
+            this.play();
+        } else {
+            this.oninit();
+        }
+
+        this.onconnect();
+    }
+
+    /**
+     * `CustomElement`. Invoked each time the custom element is disconnected from the
+     * document's DOM.
+     */
+    disconnectedCallback() {
+        if (this.background || this.disconnectTID) return;
+        if (this.wsState === WebSocket.CLOSED && this.pcState === WebSocket.CLOSED) return;
+
+        this.disconnectTID = setTimeout(() => {
+            if (this.reconnectTID) {
+                clearTimeout(this.reconnectTID);
+                this.reconnectTID = 0;
+            }
+
+            this.disconnectTID = 0;
+
+            this.ondisconnect();
+        }, this.DISCONNECT_TIMEOUT);
+    }
+
+    /**
+     * Creates child DOM elements. Called automatically once on `connectedCallback`.
+     */
+    oninit() {
+        this.video = document.createElement('video');
+        this.video.controls = true;
+        this.video.playsInline = true;
+        this.video.preload = 'auto';
+
+        this.video.style.display = 'block'; // fix bottom margin 4px
+        this.video.style.width = '100%';
+        this.video.style.height = '100%';
+
+        this.appendChild(this.video);
+
+        // all Safari lies about supported audio codecs
+        const m = window.navigator.userAgent.match(/Version\/(\d+).+Safari/);
+        if (m) {
+            // AAC from v13, FLAC from v14, OPUS - unsupported
+            const skip = m[1] < '13' ? 'mp4a.40.2' : m[1] < '14' ? 'flac' : 'opus';
+            this.CODECS.splice(this.CODECS.indexOf(skip));
+        }
+
+        if (this.background) return;
+
+        if ('hidden' in document && this.visibilityCheck) {
+            document.addEventListener('visibilitychange', () => {
+                if (document.hidden) {
+                    this.disconnectedCallback();
+                } else if (this.isConnected) {
+                    this.connectedCallback();
+                }
+            });
+        }
+
+        if ('IntersectionObserver' in window && this.visibilityThreshold) {
+            const observer = new IntersectionObserver(entries => {
+                entries.forEach(entry => {
+                    if (!entry.isIntersecting) {
+                        this.disconnectedCallback();
+                    } else if (this.isConnected) {
+                        this.connectedCallback();
+                    }
+                });
+            }, {threshold: this.visibilityThreshold});
+            observer.observe(this);
+        }
+    }
+
+    /**
+     * Connect to WebSocket. Called automatically on `connectedCallback`.
+     * @return {boolean} true if the connection has started.
+     */
+    onconnect() {
+        if (!this.isConnected || !this.wsURL || this.ws || this.pc) return false;
+
+        // CLOSED or CONNECTING => CONNECTING
+        this.wsState = WebSocket.CONNECTING;
+
+        this.connectTS = Date.now();
+
+        this.ws = new WebSocket(this.wsURL);
+        this.ws.binaryType = 'arraybuffer';
+        this.ws.addEventListener('open', () => this.onopen());
+        this.ws.addEventListener('close', () => this.onclose());
+
+        return true;
+    }
+
+    ondisconnect() {
+        this.wsState = WebSocket.CLOSED;
+        if (this.ws) {
+            this.ws.close();
+            this.ws = null;
+        }
+
+        this.pcState = WebSocket.CLOSED;
+        if (this.pc) {
+            this.pc.getSenders().forEach(sender => {
+                if (sender.track) sender.track.stop();
+            });
+            this.pc.close();
+            this.pc = null;
+        }
+
+        this.video.src = '';
+        this.video.srcObject = null;
+    }
+
+    /**
+     * @returns {Array.<string>} of modes (mse, webrtc, etc.)
+     */
+    onopen() {
+        // CONNECTING => OPEN
+        this.wsState = WebSocket.OPEN;
+
+        this.ws.addEventListener('message', ev => {
+            if (typeof ev.data === 'string') {
+                const msg = JSON.parse(ev.data);
+                for (const mode in this.onmessage) {
+                    this.onmessage[mode](msg);
+                }
+            } else {
+                this.ondata(ev.data);
+            }
+        });
+
+        this.ondata = null;
+        this.onmessage = {};
+
+        const modes = [];
+
+        if (this.mode.indexOf('mse') >= 0 && ('MediaSource' in window || 'ManagedMediaSource' in window)) {
+            modes.push('mse');
+            this.onmse();
+        } else if (this.mode.indexOf('hls') >= 0 && this.video.canPlayType('application/vnd.apple.mpegurl')) {
+            modes.push('hls');
+            this.onhls();
+        } else if (this.mode.indexOf('mp4') >= 0) {
+            modes.push('mp4');
+            this.onmp4();
+        }
+
+        if (this.mode.indexOf('webrtc') >= 0 && 'RTCPeerConnection' in window) {
+            modes.push('webrtc');
+            this.onwebrtc();
+        }
+
+        if (this.mode.indexOf('mjpeg') >= 0) {
+            if (modes.length) {
+                this.onmessage['mjpeg'] = msg => {
+                    if (msg.type !== 'error' || msg.value.indexOf(modes[0]) !== 0) return;
+                    this.onmjpeg();
+                };
+            } else {
+                modes.push('mjpeg');
+                this.onmjpeg();
+            }
+        }
+
+        return modes;
+    }
+
+    /**
+     * @return {boolean} true if reconnection has started.
+     */
+    onclose() {
+        if (this.wsState === WebSocket.CLOSED) return false;
+
+        // CONNECTING, OPEN => CONNECTING
+        this.wsState = WebSocket.CONNECTING;
+        this.ws = null;
+
+        // reconnect no more than once every X seconds
+        const delay = Math.max(this.RECONNECT_TIMEOUT - (Date.now() - this.connectTS), 0);
+
+        this.reconnectTID = setTimeout(() => {
+            this.reconnectTID = 0;
+            this.onconnect();
+        }, delay);
+
+        return true;
+    }
+
+    onmse() {
+        /** @type {MediaSource} */
+        let ms;
+
+        if ('ManagedMediaSource' in window) {
+            const MediaSource = window.ManagedMediaSource;
+
+            ms = new MediaSource();
+            ms.addEventListener('sourceopen', () => {
+                this.send({type: 'mse', value: this.codecs(MediaSource.isTypeSupported)});
+            }, {once: true});
+
+            this.video.disableRemotePlayback = true;
+            this.video.srcObject = ms;
+        } else {
+            ms = new MediaSource();
+            ms.addEventListener('sourceopen', () => {
+                URL.revokeObjectURL(this.video.src);
+                this.send({type: 'mse', value: this.codecs(MediaSource.isTypeSupported)});
+            }, {once: true});
+
+            this.video.src = URL.createObjectURL(ms);
+            this.video.srcObject = null;
+        }
+
+        this.play();
+
+        this.mseCodecs = '';
+
+        this.onmessage['mse'] = msg => {
+            if (msg.type !== 'mse') return;
+
+            this.mseCodecs = msg.value;
+
+            const sb = ms.addSourceBuffer(msg.value);
+            sb.mode = 'segments'; // segments or sequence
+            sb.addEventListener('updateend', () => {
+                if (sb.updating) return;
+
+                try {
+                    if (bufLen > 0) {
+                        const data = buf.slice(0, bufLen);
+                        bufLen = 0;
+                        sb.appendBuffer(data);
+                    } else if (sb.buffered && sb.buffered.length) {
+                        const end = sb.buffered.end(sb.buffered.length - 1) - 15;
+                        const start = sb.buffered.start(0);
+                        if (end > start) {
+                            sb.remove(start, end);
+                            ms.setLiveSeekableRange(end, end + 15);
+                        }
+                        // console.debug("VideoRTC.buffered", start, end);
+                    }
+                } catch (e) {
+                    // console.debug(e);
+                }
+            });
+
+            const buf = new Uint8Array(2 * 1024 * 1024);
+            let bufLen = 0;
+
+            this.ondata = data => {
+                if (sb.updating || bufLen > 0) {
+                    const b = new Uint8Array(data);
+                    buf.set(b, bufLen);
+                    bufLen += b.byteLength;
+                    // console.debug("VideoRTC.buffer", b.byteLength, bufLen);
+                } else {
+                    try {
+                        sb.appendBuffer(data);
+                    } catch (e) {
+                        // console.debug(e);
+                    }
+                }
+            };
+        };
+    }
+
+    onwebrtc() {
+        const pc = new RTCPeerConnection(this.pcConfig);
+
+        pc.addEventListener('icecandidate', ev => {
+            if (ev.candidate && this.mode.indexOf('webrtc/tcp') >= 0 && ev.candidate.protocol === 'udp') return;
+
+            const candidate = ev.candidate ? ev.candidate.toJSON().candidate : '';
+            this.send({type: 'webrtc/candidate', value: candidate});
+        });
+
+        pc.addEventListener('connectionstatechange', () => {
+            if (pc.connectionState === 'connected') {
+                const tracks = pc.getReceivers().map(receiver => receiver.track);
+                /** @type {HTMLVideoElement} */
+                const video2 = document.createElement('video');
+                video2.addEventListener('loadeddata', () => this.onpcvideo(video2), {once: true});
+                video2.srcObject = new MediaStream(tracks);
+            } else if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
+                pc.close(); // stop next events
+
+                this.pcState = WebSocket.CLOSED;
+                this.pc = null;
+
+                this.onconnect();
+            }
+        });
+
+        this.onmessage['webrtc'] = msg => {
+            switch (msg.type) {
+                case 'webrtc/candidate':
+                    if (this.mode.indexOf('webrtc/tcp') >= 0 && msg.value.indexOf(' udp ') > 0) return;
+
+                    pc.addIceCandidate({candidate: msg.value, sdpMid: '0'}).catch(er => {
+                        console.warn(er);
+                    });
+                    break;
+                case 'webrtc/answer':
+                    pc.setRemoteDescription({type: 'answer', sdp: msg.value}).catch(er => {
+                        console.warn(er);
+                    });
+                    break;
+                case 'error':
+                    if (msg.value.indexOf('webrtc/offer') < 0) return;
+                    pc.close();
+            }
+        };
+
+        this.createOffer(pc).then(offer => {
+            this.send({type: 'webrtc/offer', value: offer.sdp});
+        });
+
+        this.pcState = WebSocket.CONNECTING;
+        this.pc = pc;
+    }
+
+    /**
+     * @param pc {RTCPeerConnection}
+     * @return {Promise<RTCSessionDescriptionInit>}
+     */
+    async createOffer(pc) {
+        try {
+            if (this.media.indexOf('microphone') >= 0) {
+                const media = await navigator.mediaDevices.getUserMedia({audio: true});
+                media.getTracks().forEach(track => {
+                    pc.addTransceiver(track, {direction: 'sendonly'});
+                });
+            }
+        } catch (e) {
+            console.warn(e);
+        }
+
+        for (const kind of ['video', 'audio']) {
+            if (this.media.indexOf(kind) >= 0) {
+                pc.addTransceiver(kind, {direction: 'recvonly'});
+            }
+        }
+
+        const offer = await pc.createOffer();
+        await pc.setLocalDescription(offer);
+        return offer;
+    }
+
+    /**
+     * @param video2 {HTMLVideoElement}
+     */
+    onpcvideo(video2) {
+        if (this.pc) {
+            // Video+Audio > Video, H265 > H264, Video > Audio, WebRTC > MSE
+            let rtcPriority = 0, msePriority = 0;
+
+            /** @type {MediaStream} */
+            const stream = video2.srcObject;
+            if (stream.getVideoTracks().length > 0) rtcPriority += 0x220;
+            if (stream.getAudioTracks().length > 0) rtcPriority += 0x102;
+
+            if (this.mseCodecs.indexOf('hvc1.') >= 0) msePriority += 0x230;
+            if (this.mseCodecs.indexOf('avc1.') >= 0) msePriority += 0x210;
+            if (this.mseCodecs.indexOf('mp4a.') >= 0) msePriority += 0x101;
+
+            if (rtcPriority >= msePriority) {
+                this.video.srcObject = stream;
+                this.play();
+
+                this.pcState = WebSocket.OPEN;
+
+                this.wsState = WebSocket.CLOSED;
+                if (this.ws) {
+                    this.ws.close();
+                    this.ws = null;
+                }
+            } else {
+                this.pcState = WebSocket.CLOSED;
+                if (this.pc) {
+                    this.pc.close();
+                    this.pc = null;
+                }
+            }
+        }
+
+        video2.srcObject = null;
+    }
+
+    onmjpeg() {
+        this.ondata = data => {
+            this.video.controls = false;
+            this.video.poster = 'data:image/jpeg;base64,' + VideoRTC.btoa(data);
+        };
+
+        this.send({type: 'mjpeg'});
+    }
+
+    onhls() {
+        this.onmessage['hls'] = msg => {
+            if (msg.type !== 'hls') return;
+
+            const url = 'http' + this.wsURL.substring(2, this.wsURL.indexOf('/ws')) + '/hls/';
+            const playlist = msg.value.replace('hls/', url);
+            this.video.src = 'data:application/vnd.apple.mpegurl;base64,' + btoa(playlist);
+            this.play();
+        };
+
+        this.send({type: 'hls', value: this.codecs(type => this.video.canPlayType(type))});
+    }
+
+    onmp4() {
+        /** @type {HTMLCanvasElement} **/
+        const canvas = document.createElement('canvas');
+        /** @type {CanvasRenderingContext2D} */
+        let context;
+
+        /** @type {HTMLVideoElement} */
+        const video2 = document.createElement('video');
+        video2.autoplay = true;
+        video2.playsInline = true;
+        video2.muted = true;
+
+        video2.addEventListener('loadeddata', () => {
+            if (!context) {
+                canvas.width = video2.videoWidth;
+                canvas.height = video2.videoHeight;
+                context = canvas.getContext('2d');
+            }
+
+            context.drawImage(video2, 0, 0, canvas.width, canvas.height);
+
+            this.video.controls = false;
+            this.video.poster = canvas.toDataURL('image/jpeg');
+        });
+
+        this.ondata = data => {
+            video2.src = 'data:video/mp4;base64,' + VideoRTC.btoa(data);
+        };
+
+        this.send({type: 'mp4', value: this.codecs(this.video.canPlayType)});
+    }
+
+    static btoa(buffer) {
+        const bytes = new Uint8Array(buffer);
+        const len = bytes.byteLength;
+        let binary = '';
+        for (let i = 0; i < len; i++) {
+            binary += String.fromCharCode(bytes[i]);
+        }
+        return window.btoa(binary);
+    }
+}
diff --git a/www2/video-stream.js b/www2/video-stream.js
new file mode 100644
index 0000000..5b7c1ea
--- /dev/null
+++ b/www2/video-stream.js
@@ -0,0 +1,103 @@
+import {VideoRTC} from './video-rtc.js';
+
+/**
+ * This is example, how you can extend VideoRTC player for your app.
+ * Also you can check this example: https://github.com/AlexxIT/WebRTC
+ */
+class VideoStream extends VideoRTC {
+    set divMode(value) {
+        this.querySelector('.mode').innerText = value;
+        this.querySelector('.status').innerText = '';
+    }
+
+    set divError(value) {
+        const state = this.querySelector('.mode').innerText;
+        if (state !== 'loading') return;
+        this.querySelector('.mode').innerText = 'error';
+        this.querySelector('.status').innerText = value;
+    }
+
+    /**
+     * Custom GUI
+     */
+    oninit() {
+        console.debug('stream.oninit');
+        super.oninit();
+
+        this.innerHTML = `
+        <style>
+        video-stream {
+            position: relative;
+        }
+        .info {
+            position: absolute;
+            top: 0;
+            left: 0;
+            right: 0;
+            padding: 12px;
+            color: white;
+            display: flex;
+            justify-content: space-between;
+            pointer-events: none;
+        }
+        </style>
+        <div class="info">
+            <div class="status"></div>
+            <div class="mode"></div>
+        </div>
+        `;
+
+        const info = this.querySelector('.info');
+        this.insertBefore(this.video, info);
+    }
+
+    onconnect() {
+        console.debug('stream.onconnect');
+        const result = super.onconnect();
+        if (result) this.divMode = 'loading';
+        return result;
+    }
+
+    ondisconnect() {
+        console.debug('stream.ondisconnect');
+        super.ondisconnect();
+    }
+
+    onopen() {
+        console.debug('stream.onopen');
+        const result = super.onopen();
+
+        this.onmessage['stream'] = msg => {
+            console.debug('stream.onmessge', msg);
+            switch (msg.type) {
+                case 'error':
+                    this.divError = msg.value;
+                    break;
+                case 'mse':
+                case 'hls':
+                case 'mp4':
+                case 'mjpeg':
+                    this.divMode = msg.type.toUpperCase();
+                    break;
+            }
+        };
+
+        return result;
+    }
+
+    onclose() {
+        console.debug('stream.onclose');
+        return super.onclose();
+    }
+
+    onpcvideo(ev) {
+        console.debug('stream.onpcvideo');
+        super.onpcvideo(ev);
+
+        if (this.pcState !== WebSocket.CLOSED) {
+            this.divMode = 'RTC';
+        }
+    }
+}
+
+customElements.define('video-stream', VideoStream);
